use std.io;
use std.string;
use std.lists;
use std.os;
use std.arena;
use locks;

pub val SAW_VERSION: ref char = "0.0.5";

/// Represents an axe.mod file structure
model AxeMod {
    name: string;
    version: string;
    entry: string;
    description: string;
    license: string;
    dependencies: ref StringList;
}

/// Gets the platform-specific path separator
def get_path_sep(): string {
    platform windows {
        return str("\\");
    }
    platform posix {
        return str("/");
    }
    return str("/");
}

/// Gets the platform-specific executable extension
def get_exe_ext(): string {
    platform windows {
        return str(".exe");
    }
    platform posix {
        return str("");
    }
    return str("");
}

/// Reads an axe.mod file and parses it
def read_mod_file(path: string, arena: ref Arena): AxeMod {
    mut module: AxeMod;
    module.name = str("");
    module.version = str("0.1.0");
    module.entry = str("main.axe");
    module.description = str("");
    module.license = str("");
    module.dependencies = StringList.create(arena, 10);
    
    val content: string = read_file(path);
    if content.len == 0 {
        return module;
    }
    
    mut i: usize = 0;
    mut line_start: usize = 0;
    
    loop {
        if i >= content.len {
            break;
        }
        
        if content.data[i] == '\n' {
            val line: string = substr(content, cast[i32](line_start), i - line_start);
            val stripped: string = strip(line);
            
            if stripped.len > 0 {
                val colon_idx: i32 = find_char_from(stripped, ':', cast[usize](0));
                if colon_idx >= 0 {
                    val key: string = strip(substr(stripped, 0, colon_idx));
                    val value: string = strip(substr(stripped, colon_idx + 1, stripped.len - colon_idx - 1));
                    
                    if compare(key, str("name")) == 0 {
                        module.name = value;
                    } elif compare(key, str("version")) == 0 {
                        module.version = value;
                    } elif compare(key, str("entry")) == 0 {
                        module.entry = value;
                    } elif compare(key, str("description")) == 0 {
                        module.description = value;
                    } elif compare(key, str("license")) == 0 {
                        module.license = value;
                    } elif compare(key, str("dependency")) == 0 {
                        StringList.push(module.dependencies, arena, value);
                    }
                }
            }
            
            line_start = i + 1;
        }
        
        i++;
    }
    
    if line_start < content.len {
        val line: string = substr(content, cast[i32](line_start), content.len - line_start);
        val stripped: string = strip(line);
        
        if stripped.len > 0 {
            val colon_idx: i32 = find_char_from(stripped, ':', cast[usize](0));
            if colon_idx >= 0 {
                val key: string = strip(substr(stripped, 0, colon_idx));
                val value: string = strip(substr(stripped, colon_idx + 1, stripped.len - colon_idx - 1));
                
                if compare(key, str("name")) == 0 {
                    module.name = value;
                } elif compare(key, str("version")) == 0 {
                    module.version = value;
                } elif compare(key, str("entry")) == 0 {
                    module.entry = value;
                } elif compare(key, str("description")) == 0 {
                    module.description = value;
                } elif compare(key, str("license")) == 0 {
                    module.license = value;
                } elif compare(key, str("dependency")) == 0 {
                    StringList.push(module.dependencies, arena, value);
                }
            }
        }
    }
    
    return module;
}

/// Writes an axemod structure to axe.mod file
def write_mod_file(module: AxeMod, path: string) {
    mut content: string = str("");
    
    content = concat_c(content, "name: ");
    content = concat(content, module.name);
    content = concat_c(content, "\n");
    content = concat_c(content, "version: ");
    content = concat(content, module.version);
    content = concat_c(content, "\n");
    content = concat_c(content, "entry: ");
    content = concat(content, module.entry);
    content = concat_c(content, "\n");
    
    for mut i = 0; i < module.dependencies.len; i++ {
        content = concat_c(content, "dependency: ");
        content = concat(content, StringList.get(module.dependencies, i));
        content = concat_c(content, "\n");
    }
    
    write_file(path, content);
}

/// Gets the current directory name (basename of current working directory)
def get_current_dir_name(): string {
    val cwd: string = get_cwd();
    if cwd.len == 0 {
        return str("project");
    }
    
    mut last_sep: i32 = find_last_char(cwd, '/');
    val last_back: i32 = find_last_char(cwd, '\\');
    
    if last_back > last_sep {
        last_sep = last_back;
    }
    
    if last_sep < 0 {
        return cwd;
    }  
    if last_sep == cast[i32](cwd.len) - 1 and cwd.len > 1 {
        val trimmed: string = substr(cwd, 0, cwd.len - 1);
        last_sep = find_last_char(trimmed, '/');
        val last_back2: i32 = find_last_char(trimmed, '\\');
        if last_back2 > last_sep {
            last_sep = last_back2;
        }
        if last_sep < 0 {
            return trimmed;
        }
        return substr(trimmed, last_sep + 1, trimmed.len - last_sep - 1);
    }
    return substr(cwd, last_sep + 1, cwd.len - last_sep - 1);
}

/// Checks if a file contains test blocks
def has_test_blocks(file_path: string): bool {
    val content: string = read_file(file_path);
    if content.len == 0 {
        return false;
    }
    val search_pattern: string = str("test {");
    val idx: i32 = find_substr(content, search_pattern);
    return idx >= 0;
}

/// Finds all .axe files in the current directory (cross-platform)
def find_axe_files(arena: ref Arena): ref StringList {
    mut files: ref StringList = StringList.create(arena, 50);
    mut ls_cmd: string = str("");
    
    platform windows {
        ls_cmd = str("dir /b *.axe 2>nul");
    }
    platform posix {
        ls_cmd = str("ls -1 *.axe 2>/dev/null");
    }
    
    val ls_result: ExecResult = exec_capture(ls_cmd);
    
    if ls_result.exit_code == 0 and ls_result.output.len > 0 {
        mut i: usize = 0;
        mut line_start: usize = 0;
        
        loop {
            if i >= ls_result.output.len {
                break;
            }
            
            if ls_result.output.data[i] == '\n' or ls_result.output.data[i] == '\r' {
                if i > line_start {
                    val file: string = substr(ls_result.output, cast[i32](line_start), i - line_start);
                    val trimmed: string = strip(file);
                    if trimmed.len > 0 and has_suffix(trimmed, str(".axe")) {
                        StringList.push(files, arena, trimmed);
                    }
                }
                if ls_result.output.data[i] == '\r' and i + 1 < ls_result.output.len and ls_result.output.data[i + 1] == '\n' {
                    i++;
                }
                line_start = i + 1;
            }
            
            i++;
        }
        
        if line_start < ls_result.output.len {
            val file: string = substr(ls_result.output, cast[i32](line_start), ls_result.output.len - line_start);
            val trimmed: string = strip(file);
            if trimmed.len > 0 and has_suffix(trimmed, str(".axe")) {
                StringList.push(files, arena, trimmed);
            }
        }
    }
    
    return files;
}

/// Creates a directory using system command (cross-platform)
def create_dir(path: string): bool {
    mut cmd: string = str("");
    platform windows {
        cmd = concat(str("if not exist \""), path);
        cmd = concat(cmd, str("\" mkdir \""));
        cmd = concat(cmd, path);
        cmd = concat(cmd, str("\""));
    }
    platform posix {
        cmd = concat(str("mkdir -p \""), path);
        cmd = concat(cmd, str("\""));
    }
    return exec_from_string(cmd) == 0;
}

/// Parses a dependency string (url@commit) into parts
def parse_dep(dep: string, out_url: ref string, out_commit: ref string) {
    val at_idx: i32 = find_last_char(dep, '@');
    if at_idx > 0 {
        deref(out_url) = substr(dep, 0, at_idx);
        deref(out_commit) = substr(dep, at_idx + 1, dep.len - at_idx - 1);
    } else {
        deref(out_url) = dep;
        deref(out_commit) = str("");
    }
}

/// Extracts repo name from a git URL
def extract_repo_name(url: string): string {
    mut name: string = url;
    val last_slash: i32 = find_last_char(url, '/');
    if last_slash >= 0 {
        name = substr(url, last_slash + 1, url.len - last_slash - 1);
    }
    if has_suffix(name, str(".git")) {
        name = trim_suffix(name, str(".git"));
    }
    return name;
}

/// Clones a git repository and returns the commit hash
def git_clone_and_get_hash(url: string, dest_dir: string): string {
    mut clone_cmd: string = str("git clone --quiet \"");
    clone_cmd = concat(clone_cmd, url);
    clone_cmd = concat(clone_cmd, str("\" \""));
    clone_cmd = concat(clone_cmd, dest_dir);
    clone_cmd = concat(clone_cmd, str("\""));
    
    val clone_result: i32 = exec_from_string(clone_cmd);
    if clone_result != 0 {
        return str("");
    }
    
    mut hash_cmd: string = str("cd \"");
    hash_cmd = concat(hash_cmd, dest_dir);
    hash_cmd = concat(hash_cmd, str("\" && git rev-parse HEAD"));
    
    val result: ExecResult = exec_capture(hash_cmd);
    if result.exit_code == 0 {
        return strip(result.output);
    }
    
    return str("");
}

/// Checks out a specific commit in a repo
def git_checkout(repo_path: string, commit: string): bool {
    mut cmd: string = str("cd \"");
    cmd = concat(cmd, repo_path);
    cmd = concat(cmd, str("\" && git checkout --quiet "));
    cmd = concat(cmd, commit);
    return exec_from_string(cmd) == 0;
}

/// Checks if path is a git repository
def is_git_repo(path: string): bool {
    mut git_dir: string = concat(path, get_path_sep());
    git_dir = concat(git_dir, str(".git"));
    return is_directory(git_dir);
}

/// Initializes a new axe.mod file
def cmd_init(arena: ref Arena) {
    val mod_path: string = str("axe.mod");
    
    if file_exists(mod_path) {
        println "error: axe.mod already exists in this directory";
        return;
    }
    
    mut module: AxeMod;
    module.name = to_lower(get_current_dir_name());
    module.version = str("0.1.0");
    module.entry = str("main.axe");
    module.description = str("");
    module.license = str("MIT");
    module.dependencies = StringList.create(arena, 10);
    
    write_mod_file(module, mod_path);
    
    if !file_exists(str("main.axe")) {
        mut sample: string = str("use std.io;\n\n");
        sample = concat(sample, str("def main() {\n"));
        sample = concat(sample, str("    println \"Hello, World!\";\n"));
        sample = concat(sample, str("}\n"));
        write_file(str("main.axe"), sample);
        println "Created main.axe";
    }
    
    print_str(str("Initialized "));
    print_str(module.name);
    print_str(str(" v"));
    println module.version;
}

/// Adds a dependency to the project
def cmd_add(git_url: string, arena: ref Arena) {
    val mod_path: string = str("axe.mod");
    
    if !file_exists(mod_path) {
        println "error: No axe.mod file found. Run 'saw init' first.";
        return;
    }
    
    mut module: AxeMod = read_mod_file(mod_path, arena);
    val repo_name: string = extract_repo_name(git_url);
    
    for mut i = 0; i < module.dependencies.len; i++ {
        val dep: string = StringList.get(module.dependencies, i);
        if find_substr(dep, git_url) >= 0 {
            println "error: Dependency already exists.";
            return;
        }
    }
    
    val deps_dir: string = str("deps");
    if !is_directory(deps_dir) {
        create_dir(deps_dir);
    }
    
    mut dest_path: string = concat(str("deps"), get_path_sep());
    dest_path = concat(dest_path, repo_name);
    
    print_str(str("Cloning "));
    print_str(git_url);
    println "...";
    
    val commit_hash: string = git_clone_and_get_hash(git_url, dest_path);
    
    if commit_hash.len > 0 {
        mut dep_full: string = concat(git_url, str("@"));
        dep_full = concat(dep_full, commit_hash);
        
        StringList.push(module.dependencies, arena, dep_full);
        write_mod_file(module, mod_path);
        write_lock_file(module.dependencies, str("saw.lock"));
        
        print_str(str("Added: "));
        print_str(repo_name);
        print_str(str(" @ "));
        println(substr(commit_hash, 0, 8));
    } else {
        println "error: Failed to clone repository";
    }
}

/// Removes a dependency from the project
def cmd_remove(dep_name: string, arena: ref Arena) {
    val mod_path: string = str("axe.mod");
    
    if !file_exists(mod_path) {
        println "error: No axe.mod file found.";
        return;
    }
    
    mut module: AxeMod = read_mod_file(mod_path, arena);
    mut found: bool = false;
    mut new_deps: ref StringList = StringList.create(arena, 10);
    
    for mut i = 0; i < module.dependencies.len; i++ {
        val dep: string = StringList.get(module.dependencies, i);
        if find_substr(dep, dep_name) >= 0 {
            found = true;
            mut dep_path: string = concat(str("deps"), get_path_sep());
            dep_path = concat(dep_path, dep_name);
            if is_directory(dep_path) {
                rm_dir_recursive(dep_path);
            }
        } else {
            StringList.push(new_deps, arena, dep);
        }
    }
    
    if !found {
        println "error: Dependency not found.";
        return;
    }
    
    module.dependencies = new_deps;
    write_mod_file(module, mod_path);
    write_lock_file(module.dependencies, str("saw.lock"));
    print_str(str("Removed: "));
    println dep_name;
}

/// Installs all dependencies from axe.mod
def cmd_install(arena: ref Arena) {
    val mod_path: string = str("axe.mod");
    
    if !file_exists(mod_path) {
        println "error: No axe.mod file found.";
        return;
    }
    
    val module: AxeMod = read_mod_file(mod_path, arena);
    
    if module.dependencies.len == 0 {
        println "No dependencies to install.";
        return;
    }
    
    if !is_directory(str("deps")) {
        create_dir(str("deps"));
    }
    
    println "Installing dependencies...";
    
    for mut i = 0; i < module.dependencies.len; i++ {
        val dep: string = StringList.get(module.dependencies, i);
        mut url: string = str("");
        mut commit: string = str("");
        parse_dep(dep, addr(url), addr(commit));
        
        val repo_name: string = extract_repo_name(url);
        mut dest_path: string = concat(str("deps"), get_path_sep());
        dest_path = concat(dest_path, repo_name);
        
        print_str(str("  "));
        print_str(repo_name);
        
        if is_git_repo(dest_path) {
            if commit.len > 0 {
                git_checkout(dest_path, commit);
            }
            println " (cached)";
        } else {
            print_str(str(" ... "));
            val hash: string = git_clone_and_get_hash(url, dest_path);
            if hash.len > 0 {
                if commit.len > 0 {
                    git_checkout(dest_path, commit);
                }
                println "done";
            } else {
                println "failed";
            }
        }
    }
    
    write_lock_file(module.dependencies, str("saw.lock"));
    println "Done.";
}

/// Cleans build artifacts
def cmd_clean(arena: ref Arena) {
    println "Cleaning build artifacts...";
    mut cleaned: i32 = 0;
    val axe_files: ref StringList = find_axe_files(arena);
    for mut i = 0; i < axe_files.len; i++ {
        val axe_file: string = StringList.get(axe_files, i);
        val base: string = trim_suffix(axe_file, str(".axe"));
        val c_file: string = concat(base, str(".c"));
        if file_exists(c_file) {
            delete_file(c_file);
            cleaned++;
        }
        
        val exe_file: string = concat(base, get_exe_ext());
        if file_exists(exe_file) {
            delete_file(exe_file);
            cleaned++;
        }
    }
    
    print_str(str("Cleaned "));
    print_str(i32_to_string(cleaned));
    println " files.";
}

/// Shows project info
def cmd_info(arena: ref Arena) {
    val mod_path: string = str("axe.mod");
    
    if !file_exists(mod_path) {
        println "error: No axe.mod file found.";
        return;
    }
    
    val module: AxeMod = read_mod_file(mod_path, arena);
    
    println "────────────────────────────";
    print_str(str("  Name:    "));
    println module.name;
    print_str(str("\n  Version: "));
    println module.version;
    print_str(str("\n  Entry:   "));
    println module.entry;
    println "\n────────────────────────────";

    if module.description.len > 0 {
        print_str(str("  Desc:    "));
        println module.description;
    }
    if module.license.len > 0 {
        print_str(str("  License: "));
        println module.license;
    }
    
    if module.dependencies.len > 0 {
        println "";
        println "────────────────────────────\n";
        for mut i = 0; i < module.dependencies.len; i++ {
            val dep: string = StringList.get(module.dependencies, i);
            mut url: string = str("");
            mut commit: string = str("");
            parse_dep(dep, addr(url), addr(commit));
            print_str(str("  "));
            print_str(extract_repo_name(url));
            if commit.len > 0 {
                print_str(str(" @ "));
                print_str(substr(commit, 0, 8));
            }
            println "";
        }
        println "\n────────────────────────────";
    }
}

/// Builds the project by compiling the entry point from axe.mod
def cmd_build(arena: ref Arena, flags: string) {
    val mod_path: string = str("axe.mod");

    if !file_exists(mod_path) {
        println "error: No axe.mod file found. Run 'saw init' first.";
        return;
    }
    
    val module: AxeMod = read_mod_file(mod_path, arena);
    val entry_file: string = module.entry;
    
    if !file_exists(entry_file) {
        print_str(str("error: Entry point not found: "));
        println entry_file;
        return;
    }
    
    print_str(str("Building "));
    print_str(module.name);
    print_str(str(" v"));
    print_str(module.version);
    println "...";
    
    mut build_cmd: string = concat(str("axe "), entry_file);
    if flags.len > 0 {
        build_cmd = concat(build_cmd, str(" "));
        build_cmd = concat(build_cmd, flags);
    }
    build_cmd = concat(build_cmd, str(" -o "));
    build_cmd = concat(build_cmd, module.name);
    build_cmd = concat(build_cmd, get_exe_ext());
    val exit_code: i32 = exec_from_string(build_cmd);
    
    if exit_code == 0 {
        println "\nBuild successful.";
    } else {
        println "\nBuild failed.";
        quit(1);
    }
}

/// Runs the project entry point
def cmd_run(arena: ref Arena, flags: string) {
    val mod_path: string = str("axe.mod");
    
    if !file_exists(mod_path) {
        println "error: No axe.mod file found. Run 'saw init' first.";
        return;
    }
    
    val module: AxeMod = read_mod_file(mod_path, arena);
    val entry_file: string = module.entry;
    
    if !file_exists(entry_file) {
        print_str(str("error: Entry point not found: "));
        println entry_file;
        return;
    }
    
    print_str(str("Building "));
    print_str(module.name);
    println "...";
    
    mut compile_cmd: string = concat(str("axe "), entry_file);
    if flags.len > 0 {
        compile_cmd = concat(compile_cmd, str(" "));
        compile_cmd = concat(compile_cmd, flags);
    }
    val exit_code: i32 = exec_from_string(compile_cmd);
    
    if exit_code != 0 {
        println "Build failed.";
        quit(1);
    }
    
    mut exe_name: string = trim_suffix(entry_file, str(".axe"));
    exe_name = concat(exe_name, get_exe_ext());
    
    println "";
    println "────────────────────────────";
    
    exec_from_string(exe_name);
}

/// Tests all files containing test blocks
/// If module_filter is non-empty, only test files matching that name
def cmd_test(arena: ref Arena, flags: string, module_filter: string) {
    val mod_path: string = str("axe.mod");
    
    if !file_exists(mod_path) {
        println "No axe.mod file found. Run 'saw init' first.";
        return;
    }
    
    println "Finding test files...";
    
    val test_files: ref StringList = find_axe_files(arena);
    mut tests_found: i32 = 0;
    mut tests_passed: i32 = 0;
    mut tests_failed: i32 = 0;
    
    for mut i = 0; i < test_files.len; i++ {
        val file: string = StringList.get(test_files, i);
        
        if module_filter.len > 0 {
            val base_name: string = trim_suffix(file, str(".axe"));
            if compare(base_name, module_filter) != 0 {
                continue;
            }
        }
        
        if has_test_blocks(file) {
            tests_found++;
            
            print_str(str("Running tests in "));
            print_str(file);
            println "...";
            
            mut compile_cmd: string = concat(concat(str("axe "), file), str(" --quiet"));
            if flags.len > 0 {
                compile_cmd = concat(compile_cmd, str(" "));
                compile_cmd = concat(compile_cmd, flags);
            }
            val exit_code: i32 = exec_from_string(compile_cmd);
            
            if exit_code == 0 {
                mut exe_name: string = trim_suffix(file, str(".axe"));
                
                platform posix {
                    exe_name = concat(str("./"), exe_name);
                }

                val run_code: i32 = exec_from_string(exe_name);
                
                if run_code == 0 {
                    tests_passed++;
                    println "All tests passed";
                } else {
                    tests_failed++;
                    println "Tests failed";
                }
            } else {
                tests_failed++;
                println "Compilation failed";
            }
            
            println "";
        }
    }
    
    print_str(str("Tests found: "));
    println(i32_to_string(tests_found));
    print_str(str("\nPassed: "));
    println(i32_to_string(tests_passed));
    print_str(str("Failed: "));
    println(i32_to_string(tests_failed));
}


/// Checks files for compilation errors
def cmd_check(arena: ref Arena, args: ref StringList) {
    mut check_all: bool = false;
    mut full_compile: bool = false;
    mut target_file: string = str("");
    
    for mut i = 2; i < args.len; i++ {
        val arg: string = StringList.get(args, i);
        if compare(arg, str("--all")) == 0 {
            check_all = true;
        } elif compare(arg, str("--full")) == 0 {
            full_compile = true;
        } elif !has_prefix(arg, str("-")) {
            target_file = arg;
        }
    }
    
    if !check_all and target_file.len == 0 {
        println "error: 'check' requires a file path or --all";
        return;
    }
    
    mut files_to_check: ref StringList = StringList.create(arena, 10);
    
    if check_all {
        files_to_check = find_axe_files(arena);
    } else {
        if !has_suffix(target_file, str(".axe")) and !file_exists(target_file) {
            target_file = concat(target_file, str(".axe"));
        }
        
        if !file_exists(target_file) {
             print_str(str("error: File not found: "));
             println target_file;
             return;
        }
        StringList.push(files_to_check, arena, target_file);
    }
    
    mut passed: i32 = 0;
    mut failed: i32 = 0;
    
    for mut i = 0; i < files_to_check.len; i++ {
        val file: string = StringList.get(files_to_check, i);
        print_str(str("Checking "));
        print_str(file);
        println "...";
        
        mut cmd: string = concat(str("axe "), file);
        cmd = concat(cmd, str(" --quiet"));
        
        if !full_compile {
            cmd = concat(cmd, str(" --syntax-only"));
        }
        
        val exit_code: i32 = exec_from_string(cmd);
        
        if exit_code == 0 {
            passed++;
        } else {
            failed++;
        }
    }
    
    if files_to_check.len > 1 {
        println "";
        print("Checked: ");
        println(i32_to_string(passed + failed));
        print("\nPassed:  ");
        println(i32_to_string(passed));
        print("\nFailed:  ");
        println(i32_to_string(failed));
    }
    
    if failed > 0 {
        quit(1);
    }
}

/// Collects compiler flags from arguments starting at given index
def collect_flags(args: ref StringList, start_idx: i32): string {
    mut flags: string = str("");
    for mut i = start_idx; i < args.len; i++ {
        val arg: string = StringList.get(args, i);
        if has_prefix(arg, str("-")) {
            if flags.len > 0 {
                flags = concat(flags, str(" "));
            }
            flags = concat(flags, arg);
        }
    }
    return flags;
}

/// Shows help information
def show_help() {
    println "Usage:";
    println "    saw <command> [options]";
    println "";
    println "Commands:";
    println "    init                   Initialize a new Axe project";
    println "    build [flags]          Build the project";
    println "    run   [flags]          Build and run the project";
    println "    check [file|--all]     Check for compilation errors";
    println "    test  [module] [flags] Run tests (optionally for a specific module)";
    println "    clean                  Remove build artifacts";
    println "    info                   Show project information";
    println "";
    println "    add    <url>           Add a git dependency";
    println "    remove <name>          Remove a dependency";
    println "    install                Install all dependencies";
    println "";
    println "    help, -h               Show this help message";
    println "    --version, -v          Show version";
    println "";
    println "Flags:";
    println "    --release               Build with optimizations";
    println "    --debug                 Build with debug symbols";
    println "    (etc...)                Other axe compiler flags...\n";
}

def main() {
    mut arena: Arena = Arena.create(2097152);
    val args: ref StringList = get_cmdline_args(addr(arena));
    
    if args.len < 2 {
        show_help();
        Arena.destroy(addr(arena));
        return;
    }
    
    val command: string = StringList.get(args, 1);
    
    if compare(command, str("init")) == 0 {
        cmd_init(addr(arena));
    } elif compare(command, str("add")) == 0 {
        if args.len < 3 {
            println "error: 'add' requires a git URL";
            println "Usage: saw add <git-url>";
        } else {
            val git_url: string = StringList.get(args, 2);
            cmd_add(git_url, addr(arena));
        }
    } elif compare(command, str("remove")) == 0 or compare(command, str("rm")) == 0 {
        if args.len < 3 {
            println "error: 'remove' requires a dependency name";
        } else {
            val dep_name: string = StringList.get(args, 2);
            cmd_remove(dep_name, addr(arena));
        }
    } elif compare(command, str("install")) == 0 or compare(command, str("i")) == 0 {
        cmd_install(addr(arena));
    } elif compare(command, str("build")) == 0 or compare(command, str("b")) == 0 {
        val flags: string = collect_flags(args, 2);
        cmd_build(addr(arena), flags);
    } elif compare(command, str("run")) == 0 or compare(command, str("r")) == 0 {
        val flags: string = collect_flags(args, 2);
        cmd_run(addr(arena), flags);
    } elif compare(command, str("test")) == 0 or compare(command, str("t")) == 0 {
        mut module_filter: string = str("");
        mut flags_start: i32 = 2;
        if args.len > 2 {
            val potential_module: string = StringList.get(args, 2);
            if !has_prefix(potential_module, str("-")) {
                module_filter = potential_module;
                flags_start = 3;
            }
        }
        val flags: string = collect_flags(args, flags_start);
        cmd_test(addr(arena), flags, module_filter);
    } elif compare(command, str("check")) == 0 or compare(command, str("c")) == 0 {
        cmd_check(addr(arena), args);
    } elif compare(command, str("clean")) == 0 {
        cmd_clean(addr(arena));
    } elif compare(command, str("info")) == 0 {
        cmd_info(addr(arena));
    } elif compare(command, str("help")) == 0 or compare(command, str("-h")) == 0 or compare(command, str("--help")) == 0 {
        show_help();
    } elif compare(command, str("--version")) == 0 or compare(command, str("-v")) == 0 {
        print_str(str("saw "));
        print_chrptr SAW_VERSION;
    } else {
        print_str(str("error: Unknown command: "));
        println command;
        println "Run 'saw help' for usage.";
        quit(1);
    }
    
    Arena.destroy(addr(arena));
}
