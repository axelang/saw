use std.io;
use std.string;
use std.lists (
    StringList
);
use std.os;
use std.arena (
    Arena
);

/// Represents an axe.mod file structure
model AxeMod {
    name: string;
    version: string;
    entry: string;
    dependencies: ref StringList;
}

/// Reads an axe.mod file and parses it
def read_mod_file(path: string, arena: ref Arena): AxeMod {
    mut module: AxeMod;
    module.name = str("");
    module.version = str("0.1.0");
    module.entry = str("main.axe");
    module.dependencies = StringList.create(arena, 10);
    
    val content: string = read_file(path);
    if content.len == 0 {
        return module;
    }
    
    mut i: usize = 0;
    mut line_start: usize = 0;
    
    loop {
        if i >= content.len {
            break;
        }
        
        if content.data[i] == '\n' {
            val line: string = substr(content, line_start, i - line_start);
            val stripped: string = strip(line);
            
            if stripped.len > 0 {
                val colon_idx: i32 = find_char_from(stripped, ':', 0);
                if colon_idx >= 0 {
                    val key: string = strip(substr(stripped, 0, colon_idx));
                    val value: string = strip(substr(stripped, colon_idx + 1, stripped.len - colon_idx - 1));
                    
                    if compare(key, str("name")) == 0 {
                        module.name = value;
                    } elif compare(key, str("version")) == 0 {
                        module.version = value;
                    } elif compare(key, str("entry")) == 0 {
                        module.entry = value;
                    } elif compare(key, str("dependency")) == 0 {
                        StringList.push(module.dependencies, arena, value);
                    }
                }
            }
            
            line_start = i + 1;
        }
        
        i++;
    }
    
    if line_start < content.len {
        val line: string = substr(content, line_start, content.len - line_start);
        val stripped: string = strip(line);
        
        if stripped.len > 0 {
            val colon_idx: i32 = find_char_from(stripped, ':', 0);
            if colon_idx >= 0 {
                val key: string = strip(substr(stripped, 0, colon_idx));
                val value: string = strip(substr(stripped, colon_idx + 1, stripped.len - colon_idx - 1));
                
                if compare(key, str("name")) == 0 {
                    module.name = value;
                } elif compare(key, str("version")) == 0 {
                    module.version = value;
                } elif compare(key, str("entry")) == 0 {
                    module.entry = value;
                } elif compare(key, str("dependency")) == 0 {
                    StringList.push(module.dependencies, arena, value);
                }
            }
        }
    }
    
    return module;
}

/// Writes an AxeMod structure to axe.mod file
def write_mod_file(module: AxeMod, path: string) {
    mut content: string = str("");
    
    content = concat(content, str("name: "));
    content = concat(content, module.name);
    content = concat(content, str("\n"));
    content = concat(content, str("version: "));
    content = concat(content, module.version);
    content = concat(content, str("\n"));
    content = concat(content, str("entry: "));
    content = concat(content, module.entry);
    content = concat(content, str("\n"));
    
    for mut i = 0; i < module.dependencies.len; i++ {
        content = concat(content, str("dependency: "));
        content = concat(content, StringList.get(module.dependencies, i));
        content = concat(content, str("\n"));
    }
    
    write_file(path, content);
}

/// Gets the current directory name in lowercase
/// For now, just returns "project" as a default
def get_current_dir_name(): string {
    return get_cwd();
}

/// Checks if a file contains test blocks
def has_test_blocks(file_path: string): bool {
    val content: string = read_file(file_path);
    if content.len == 0 {
        return false;
    }
    val search_pattern: string = str("test {");
    val idx: i32 = find_substr(content, search_pattern);
    return idx >= 0;
}

/// Finds all .axe files in the current directory
def find_axe_files(arena: ref Arena): ref StringList {
    mut files: ref StringList = StringList.create(arena, 50);
    val ls_result: ExecResult = exec_capture(str("ls *.axe"));
    
    if ls_result.exit_code == 0 and ls_result.output.len > 0 {
        mut i: usize = 0;
        mut line_start: usize = 0;
        
        loop {
            if i >= ls_result.output.len {
                break;
            }
            
            if ls_result.output.data[i] == '\n' {
                val file: string = substr(ls_result.output, line_start, i - line_start);
                val trimmed: string = strip(file);
                if trimmed.len > 0 and has_suffix(trimmed, str(".axe")) {
                    StringList.push(files, arena, trimmed);
                }
                line_start = i + 1;
            }
            
            i++;
        }
        
        if line_start < ls_result.output.len {
            val file: string = substr(ls_result.output, line_start, ls_result.output.len - line_start);
            val trimmed: string = strip(file);
            if trimmed.len > 0 and has_suffix(trimmed, str(".axe")) {
                StringList.push(files, arena, trimmed);
            }
        }
    }
    
    return files;
}

/// Creates a directory using system command
def create_dir(path: string) {
    val mkdir_cmd: string = concat(str("mkdir "), path);
    exec_from_string(mkdir_cmd);
}

/// Clones a git repository and returns the commit hash
def git_clone_and_get_hash(url: string, dest_dir: string): string {
    val clone_cmd: string = concat(str("git clone "), url);
    val clone_cmd2: string = concat(clone_cmd, str(" "));
    val clone_cmd3: string = concat(clone_cmd2, dest_dir);
    
    exec_from_string(clone_cmd3);
    
    val hash_file: string = str("deps/.saw_hash_temp");
    mut hash_cmd: string = str("cd ");
    hash_cmd = concat(hash_cmd, dest_dir);
    hash_cmd = concat(hash_cmd, str(" && git rev-parse HEAD > ../"));
    hash_cmd = concat(hash_cmd, hash_file);
    
    exec_from_string(hash_cmd);
    
    mut hash: string = str("");
    if file_exists(hash_file) {
        hash = read_file(hash_file);
        hash = strip(hash);
        delete_file(hash_file);
    }
    
    return hash;
}

/// Initializes a new axe.mod file
def cmd_init(arena: ref Arena) {
    val mod_path: string = str("axe.mod");
    
    if file_exists(mod_path) {
        println "axe.mod already exists in this directory";
        return;
    }
    
    mut module: AxeMod;
    module.name = get_current_dir_name();
    module.version = str("0.1.0");
    module.dependencies = StringList.create(arena, 10);
    
    write_mod_file(module, mod_path);
    
    print_str(str("Initialized "));
    print_str(module.name);
    println " project with axe.mod";
}

/// Adds a dependency to the project
def cmd_add(git_url: string, arena: ref Arena) {
    val mod_path: string = str("axe.mod");
    
    if !file_exists(mod_path) {
        println "No axe.mod file found. Run 'saw init' first.";
        return;
    }
    
    mut module: AxeMod = read_mod_file(mod_path, arena);
    mut repo_name: string = git_url;
    val last_slash: i32 = find_char_from(git_url, '/', git_url.len - 1);
    if last_slash >= 0 {
        repo_name = substr(git_url, last_slash + 1, git_url.len - last_slash - 1);
    }
    
    if has_suffix(repo_name, str(".git")) {
        repo_name = trim_suffix(repo_name, str(".git"));
    }
    
    val deps_dir: string = str("deps");
    if !is_directory(deps_dir) {
        create_dir(deps_dir);
    }
    
    val dest_path: string = concat(str("deps/"), repo_name);
    
    print_str(str("Cloning "));
    print_str(git_url);
    println "...";
    
    val commit_hash: string = git_clone_and_get_hash(git_url, dest_path);
    
    if commit_hash.len > 0 {
        val dep_entry: string = concat(git_url, str("@"));
        val dep_full: string = concat(dep_entry, commit_hash);
        
        StringList.push(module.dependencies, arena, dep_full);
        write_mod_file(module, mod_path);
        
        print_str(str("Added dependency: "));
        print_str(repo_name);
        print_str(str(" ("));
        print_str(substr(commit_hash, 0, 8));
        println ")";
    } else {
        println "Failed to clone repository or get commit hash";
    }
}

/// Builds the project by compiling the entry point from axe.mod
def cmd_build(arena: ref Arena, flags: string) {
    val mod_path: string = str("axe.mod");

    if !file_exists(mod_path) {
        println "No axe.mod file found. Run 'saw init' first.";
        return;
    }
    
    mut module: AxeMod = read_mod_file(mod_path, arena);
    val entry_file: string = module.entry;
    
    if !file_exists(entry_file) {
        print_str(str("Entry point file not found: "));
        println entry_file;
        return;
    }
    
    print_str(str("Building "));
    print_str(entry_file);
    println "...";
    
    mut build_cmd: string = concat(str("axe "), entry_file);
    if flags.len > 0 {
        build_cmd = concat(build_cmd, str(" "));
        build_cmd = concat(build_cmd, flags);
    }
    val exit_code: i32 = exec_from_string(build_cmd);
    
    if exit_code == 0 {
        println "\nBuild successful.";
    } else {
        println "\nBuild failed.";
    }
}

/// Runs the project entry point
def cmd_run(arena: ref Arena, flags: string) {
    val mod_path: string = str("axe.mod");
    
    if !file_exists(mod_path) {
        println "No axe.mod file found. Run 'saw init' first.";
        return;
    }
    
    mut module: AxeMod = read_mod_file(mod_path, arena);
    val entry_file: string = module.entry;
    
    if !file_exists(entry_file) {
        print_str(str("Entry point file not found: "));
        println entry_file;
        return;
    }
    
    print_str(str("Running "));
    print_str(entry_file);
    println "...";
    
    mut compile_cmd: string = concat(str("axe "), entry_file);
    if flags.len > 0 {
        compile_cmd = concat(compile_cmd, str(" "));
        compile_cmd = concat(compile_cmd, flags);
    }
    val exit_code: i32 = exec_from_string(compile_cmd);
    
    if exit_code != 0 {
        println "Compilation failed.";
        return;
    }
    
    val exe_name: string = trim_suffix(entry_file, str(".axe"));
    
    println "";
    print_str(str("--- Output from "));
    print_str(exe_name);
    println " ---";
    println "";
    
    exec_from_string(exe_name);
}

/// Tests all files containing test blocks
def cmd_test(arena: ref Arena) {
    val mod_path: string = str("axe.mod");
    
    if !file_exists(mod_path) {
        println "No axe.mod file found. Run 'saw init' first.";
        return;
    }
    
    println "Finding test files...";
    
    val test_files: ref StringList = find_axe_files(arena);
    mut tests_found: i32 = 0;
    mut tests_passed: i32 = 0;
    mut tests_failed: i32 = 0;
    
    for mut i = 0; i < test_files.len; i++ {
        val file: string = StringList.get(test_files, i);
        
        if has_test_blocks(file) {
            tests_found++;
            
            print_str(str("Running tests in "));
            print_str(file);
            println "...";
            
            val compile_cmd: string = concat(str("axe "), file);
            val exit_code: i32 = exec_from_string(compile_cmd);
            
            if exit_code == 0 {
                val exe_name: string = trim_suffix(file, str(".axe"));
                val run_code: i32 = exec_from_string(exe_name);
                
                if run_code == 0 {
                    tests_passed++;
                    println "All tests passed";
                } else {
                    tests_failed++;
                    println "Tests failed";
                }
            } else {
                tests_failed++;
                println "Compilation failed";
            }
            
            println "";
        }
    }
    
    print_str(str("Tests found: "));
    println(i32_to_string(tests_found));
    print_str(str("\nPassed: "));
    println(i32_to_string(tests_passed));
    print_str(str("\nFailed: "));
    println(i32_to_string(tests_failed));
}

/// Collects compiler flags from arguments starting at given index
def collect_flags(args: ref StringList, start_idx: i32): string {
    mut flags: string = str("");
    for mut i = start_idx; i < args.len; i++ {
        val arg: string = StringList.get(args, i);
        if has_prefix(arg, str("-")) {
            if flags.len > 0 {
                flags = concat(flags, str(" "));
            }
            flags = concat(flags, arg);
        }
    }
    return flags;
}

/// Shows help information
def show_help() {
    println "Usage: saw <command> [options]";
    println "";
    println "  saw init              Initialize a new axe.mod file";
    println "  saw add <git-url>     Add a dependency from a git repository";
    println "  saw build [flags]     Build the project (compile entry point)";
    println "  saw run [flags]       Build and run the project";
    println "  saw test              Run all tests in project";
    println "  saw help              Show this help message";
    println "";
    println "Compiler flags can be passed through to the underlying Axe compiler:\n";
    println "  --release             Build with optimizations";
    println "  --debug               Build with debug info";
    println "  (etc...)              Any other flags are passed through\n";
}

def main() {
    mut arena: Arena = Arena.create(1048576);
    val args: ref StringList = get_cmdline_args(addr(arena));
    
    if args.len < 2 {
        show_help();
        return;
    }
    
    val command: string = StringList.get(args, 1);
    
    if compare(command, str("init")) == 0 {
        cmd_init(addr(arena));
    } elif compare(command, str("add")) == 0 {
        if args.len < 3 {
            println "Error: 'add' command requires a git URL";
            println "Usage: saw add <git-url>";
        } else {
            val git_url: string = StringList.get(args, 2);
            cmd_add(git_url, addr(arena));
        }
    } elif compare(command, str("build")) == 0 {
        val flags: string = collect_flags(args, 2);
        cmd_build(addr(arena), flags);
    } elif compare(command, str("run")) == 0 {
        val flags: string = collect_flags(args, 2);
        cmd_run(addr(arena), flags);
    } elif compare(command, str("test")) == 0 {
        cmd_test(addr(arena));
    } elif compare(command, str("help")) == 0 {
        show_help();
    } elif compare(command, str("--version")) == 0 or compare(command, str("-v")) == 0 {
        println "v0.0.1";
    } else {
        print_str(str("Unknown command: "));
        println command;
        println "";
        show_help();
    }
    
    Arena.destroy(addr(arena));
}
